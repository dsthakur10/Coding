/*

You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly
connected to the jth node if graph[i][j] == 1.

Some nodes initial are initially infected by malware. Whenever two nodes are directly connected,
and at least one of those two nodes is infected by malware, both nodes will be infected by malware.
This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of
malware stops. WE WILL REMOVE EXACTLY ONE NODE FROM INITIAL.

Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize
M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to
the malware spread.


Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

Example 3:
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1

*/

// NOTE : Node is to be "fixed" in the given question & NOT "removed" --> Question description lacks proper info

// test case that failed because of WRONG word: [[1,1,0],[1,1,0],[0,0,1]]    , [0,1,2]

class UnionFind {

private:
    vector<int> root;
    vector<int> rank;
    vector<int> sizeOfComponent;

public:
    UnionFind(int sz) : root(sz), rank(sz), sizeOfComponent(sz)
    {
        for (int i = 0; i < sz; i++)
        {
            root[i] = i;
            rank[i] = 1;
            sizeOfComponent[i] = 1;
        }
    }

    int find(int x) {
        if (x == root[x])
            return x;

        return root[x] = find(root[x]);
    }

    void unionSet(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY)
        {
            if (rank[rootX] > rank[rootY])
                root[rootY] = rootX;

            else if (rank[rootX] < rank[rootY])
                root[rootX] = rootY;

            else
            {
                root[rootY] = rootX;
                rank[rootX] += 1;
            }
        }

        sizeOfComponent[rootX] += sizeOfComponent[rootY];
        sizeOfComponent[rootY] = sizeOfComponent[rootX];
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }

    int componentSize(int x)
    {
        int rootX = find(x);
        return sizeOfComponent[rootX];
    }

};



// WRONG Approach

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

    int n = graph.size();
    UnionFind uf(n);

    for(int i=0; i<n-1; i++)
    {
        for(int j=0; j<n; j++)
        {
            if(graph[i][j] && !uf.connected(i,j))
                uf.unionSet(i, j);
        }
    }

    sort(initial.begin(), initial.end());
    int maxGroup = -1, removeNode = -1;
    vector<int> group(n, 0);

    for(int x: initial)
    {
        group[x] = uf.componentSize(x);
    }


    for(int x: initial)
    {
        if(maxGroup < group[x])
        {
            maxGroup = group[x];
            removeNode = x;
        }
    }

    return removeNode;
}



// Method-2 :
/*

1. Union find all the nodes.
2. Count the size of each disjoint-set.
3. Count the #malwares for each union set.

    - Return the largest disjoint-set's malware if there is one and only one malware in this disjoint set.

    - If there is no such disjoint-set with only 1 malware, remove the malware with minimum index.

The node belonging to the biggest size group such that it is the only initially infected node in that group
is the answer as removing it would prevent the most number of nodes from getting infected.

If there are multiple nodes like this remove the one with lowest index value
('initial' vector is sorted for this reason)


Because we have to remove 1 node from initial if we have more than 1 node in initial which are part of the
same connected component, there is no way removing one of them will stop malware in that component.

*/

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

    int n = graph.size();
    UnionFind uf(n);

    for(int i=0; i<n-1; i++)
    {
        for(int j=0; j<n; j++)
        {
            // UnionFind all connected nodes
            if(graph[i][j] && !uf.connected(i,j))
                uf.unionSet(i, j);
        }
    }

    sort(initial.begin(), initial.end());

    vector<int> group(n, 0);
    vector<int> infect(n, 0);


    // get the size of each group

    for(int i=0; i<n; i++)
        group[i] = uf.componentSize(i);


    // get the #infected nodes in each group (those group whose nodes are initially infected)

    for(int x: initial)
        infect[uf.find(x)]++;


    // get the largest group with infected nodes = 1 --> return that node
    // else return the infected node with smallest index

    int maxGroup = -1, removeNode = initial[0];

    for(int x: initial)
    {
        if(infect[uf.find(x)] == 1 && maxGroup < group[x])
        {
            maxGroup = group[x];
            removeNode = x;
        }
    }

    return removeNode;
}
